#! /usr/bin/env python
# -*- encoding:utf-8 -*-
# modified from pydf [https://github.com/garabik/pydf]

import sys
import unicodedata
from collections import defaultdict

try:
    import xml.etree.cElementTree as ET
except ImportError:
    import xml.etree.ElementTree as ET

try:
    from commands import  getstatusoutput
except ImportError:
    from subprocess import getstatusoutput


#some default definitions
COLORS = {
    'none'       :    "",
    'default'    :    "\033[0m",
    'bold'       :    "\033[1m",
    'underline'  :    "\033[4m",
    'blink'      :    "\033[5m",
    'reverse'    :    "\033[7m",
    'concealed'  :    "\033[8m",

    'black'      :    "\033[30m",
    'red'        :    "\033[31m",
    'green'      :    "\033[32m",
    'yellow'     :    "\033[33m",
    'blue'       :    "\033[34m",
    'magenta'    :    "\033[35m",
    'cyan'       :    "\033[36m",
    'white'      :    "\033[37m",

    'on_black'   :    "\033[40m",
    'on_red'     :    "\033[41m",
    'on_green'   :    "\033[42m",
    'on_yellow'  :    "\033[43m",
    'on_blue'    :    "\033[44m",
    'on_magenta' :    "\033[45m",
    'on_cyan'    :    "\033[46m",
    'on_white'   :    "\033[47m",

    'beep'       :    "\007"
}


BAR = '#'
FILL = '.'
class Bar(object):
    "Progress bar"
    def __init__(self, percentage=0, width=40, header=False):
        self.percentage = percentage
        self.width = width
        self.header = header

    def __len__(self):
        return self.width

    def __str__(self):
        return self.format('l')

    def format(self, pos):
        if self.header:
            return ' '*self.width
        size = min(int(round(self.percentage*(self.width-2))), self.width-2)
        return '[' + manglestring(size * BAR, self.width - 2, pos, FILL) + ']'


def get_queue():
    """Get nodes for all quque"""
    queue_info = defaultdict(list)
    status, output = getstatusoutput("qmgr -c 'p s' | grep queue | grep acl_hosts | awk '{print $3,$6}'")
    for line in output.splitlines():
        queue, node = line.split()
        queue_info[node] = queue
        # queue_info[queue].append(node)
    return queue_info


STATE_COLOR = {
    'free': "green",
    'busy': "cyan",
    'excl': "red",
    'down': "default",
    'offl': "on_red",
    'UNKN': "default",
}

STATE = {
    'job-exclusive': 'excl',
    'job-exclusive,busy': 'busy',
    'busy': 'busy',
    'free': 'free',
    'offline': 'offl',
    'offline,job-exclusive': 'offl',
    'offline,job-exclusive,busy': 'offl',
    'down': 'down',
    'down,busy': 'down',
    'down,offline': 'down',
    'down,job-exclusive': 'down',
    'down,offline,job-exclusive': 'down',
    'down,offline,busy': 'down',
    'down,offline,job-exclusive, busy': 'down',
    'UNKN': 'UNKN',
}

def get_stat(queue_info):
    """Parse pbsnodes output"""
    nodes_stat = []
    status, output = getstatusoutput("pbsnodes -aox")
    root = ET.fromstring(output)
    for node in root:
        name = node.find('name').text
        if name not in queue_info:
            continue
        queue = queue_info[name]
        state = STATE[node.find('state').text]

        ncpus = int(node.find('np').text)

        # optional field
        status = node.find('status')
        if status is None:
            mem = None
            aval = None
            used = None
        else:
            status = node.find('status').text
            status_d = dict((i.split('=')[0], i.split('=')[1]) for i in status.split(','))

            mem = float(status_d['totmem'][:-2]) / 1024 / 1024
            aval = float(status_d['availmem'][:-2]) / 1024 / 1024
            used = mem - aval

        # load = float(status_d['loadave'])
        jobs = node.find('jobs')
        load = 0 if jobs is None else len(jobs.text.split(','))

        if load == 0 and state == 'busy':
            state = 'UNKN'

        node_info = [
            (COLORS['default'], name),
            (COLORS[STATE_COLOR[state]], state),
            (COLORS[STATE_COLOR[state]], '' if used is None else '{0:.1f}'.format(used)),
            (COLORS[STATE_COLOR[state]], '' if mem is None else '{0:.1f}'.format(mem)),
            (COLORS[STATE_COLOR[state]], '' if aval is None else '{0:.1f}'.format(aval)),
            (COLORS['default'], ncpus),
            (COLORS[STATE_COLOR[state]], '{0:2d}'.format(load)),
            (COLORS[STATE_COLOR[state]], Bar(percentage=load/ncpus)),
            (COLORS['default'], queue),
        ]
        nodes_stat.append(node_info)
    return nodes_stat


FORMAT = [
    ('node', 10, "l"), ('state', 7, "r"),
    ('used', 7, "r"), ('mem', 7, "r"), ('avail', 7, "r"), ('ncpus', 5, "r"), ('perc', 7, "r"),
    ('bar', 40, "l"), ('queue', 11, "l")
]
def manglestring(s, l, pos, fillchar=' '):
    "cut string to fit exactly into l chars"
    if pos == "r":
        ns = str.rjust(s, l, fillchar)
    elif pos == "l":
        ns = str.ljust(s, l, fillchar)
    elif pos == "c":
        ns = str.center(s, l, fillchar)
    else:
        raise ValueError('Error in manglestring')
    if len(ns) > l:
        ns = ns[:int(l/2)] + "~" + ns[-int(l/2)+1:]
    return ns


def out(s):
    try:
        sys.stdout.write(s)
    except UnicodeEncodeError:
        sys.stdout.write(s.encode('ascii', 'ignore').decode())


HEADER = {
    'node': "Node",
    'state': "State",
    'used': "Used",
    'mem': "Mem",
    'avail': "Avail",
    'ncpus': 'CPU',
    'perc': "Load",
    'bar': str(Bar(header=True)),
    'queue': "Queue",
}
def display_table(table):
    header_colour = "yellow"
    for i, j in enumerate(FORMAT):
        width, pos = FORMAT[i][1:3]
        out(COLORS[header_colour])
        out(manglestring(HEADER[str(j[0])], width, pos))
        out(COLORS[header_colour])
        out(' ')
    out('\n')

    for row in table:
        for i, j in enumerate(row):
            width, pos = FORMAT[i][1:3]
            out(j[0])
            out(manglestring(str(j[1]), width, pos))
            out(COLORS['none'])
            out(' ')
        out(COLORS['default'])
        out('\n')


def main():
    """Main func"""
    queue_info = get_queue()
    nodes_info = get_stat(queue_info)
    display_table(nodes_info)


if __name__ == "__main__":
    main()
